# Exercise 7.1
![Ex7 1](https://github.com/65030179179Pattarapon/03376836-OOP-2566-Lab-11/assets/144198506/f4643bd2-c2e9-45d3-8cd3-7a60276df9f0)

# Exercise 7.2
![Ex7 2](https://github.com/65030179179Pattarapon/03376836-OOP-2566-Lab-11/assets/144198506/b2304e40-42b1-4fb9-bb61-72dffe8ef351)

##
#### ในการทดลองนี้เรามีคลาส Base ที่มีเมทอด A() ที่ถูกประกาศเป็น virtual เพื่อให้สามารถโอเวอร์ไรด์ได้ และคลาส Derived_1 ที่โอเวอร์ไรด์เมทอด A() จาก Base และประกาศเมทอด A() ใหม่ (new) ใน Derived_2 โดยที่มันไม่ได้เชื่อมโยงกับการโอเวอร์ไรด์ใด ๆ ซึ่งเป็นไปตามแนวทางการเรียกใช้เมทอดของแต่ละอ็อบเจกต์ว่าถูกต้องตามลำดับของการสืบทอด ดังนั้นเมื่อเรียกใช้เมทอด A() ผ่านอ็อบเจกต์ b และ d1 จะเรียกใช้เมทอด A() ที่ถูกโอเวอร์ไรด์ใน Derived_1 และเมื่อเรียกใช้เมทอด A() ผ่านอ็อบเจกต์ d2 จะเรียกใช้เมทอด A() ที่ถูกประกาศใหม่ใน Derived_2 ทำให้เมทอด A() ใน Derived_2 ไม่ได้เรียกใช้เมทอด A() ใด ๆ ที่ถูกโอเวอร์ไรด์ไว้ก่อนหน้านี้ในโค้ด สรุปได้ว่า การใช้งานการโอเวอร์ไรด์และการประกาศเมทอดใหม่ใน C# ถูกจัดการอย่างถูกต้องและให้ผลลัพธ์ตามที่คาดหวัง
